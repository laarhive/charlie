<!-- public/bus.html -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Charlie Bus Monitor</title>
    <style>
        body { font-family: system-ui, sans-serif; margin: 16px; }
        .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .pill { padding: 4px 10px; border-radius: 999px; background: #eee; }
        button { padding: 6px 10px; }
        pre { background: #111; color: #ddd; padding: 12px; border-radius: 8px; overflow: auto; max-height: 70vh; }
        input { padding: 6px 8px; min-width: 260px; }
        small { color: #555; }
    </style>
</head>
<body>
<h1>Charlie Bus Monitor</h1>

<div class="row">
    <div class="pill" id="status">disconnected</div>

    <label>
        Stream:
        <input id="wsUrl" />
    </label>

    <button id="connectBtn">Connect</button>
    <button id="clearBtn">Clear</button>
</div>

<p><small>Tip: use <code>?main&amp;button</code> or <code>?all</code> on the stream URL.</small></p>

<pre id="log"></pre>

<script>
  const statusEl = document.getElementById('status')
  const logEl = document.getElementById('log')
  const wsUrlEl = document.getElementById('wsUrl')
  const connectBtn = document.getElementById('connectBtn')
  const clearBtn = document.getElementById('clearBtn')

  const defaultWsUrl = (() => {
    const isHttps = location.protocol === 'https:'
    const wsProto = isHttps ? 'wss:' : 'ws:'
    return `${wsProto}//${location.host}/ws?all`
  })()

  wsUrlEl.value = defaultWsUrl

  let ws = null
  let closedByUser = false
  let attempt = 0
  let reconnectTimer = null

  const logLine = (line) => {
    logEl.textContent += line + '\n'
    logEl.scrollTop = logEl.scrollHeight
  }

  const setStatus = (text) => {
    statusEl.textContent = text
  }

  const clearReconnectTimer = () => {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer)
      reconnectTimer = null
    }
  }

  const backoffMs = () => {
    const min = 250
    const max = 10_000
    const exp = Math.min(max, min * Math.pow(2, attempt))
    const jitter = exp * 0.25 * (Math.random() * 2 - 1)
    return Math.max(min, Math.floor(exp + jitter))
  }

  const scheduleReconnect = () => {
    if (closedByUser) {
      return
    }

    clearReconnectTimer()
    const ms = backoffMs()
    setStatus(`reconnecting in ${ms}ms`)
    reconnectTimer = setTimeout(() => {
      attempt += 1
      connect()
    }, ms)
  }

  const connect = () => {
    const url = wsUrlEl.value.trim()
    if (!url) {
      return
    }

    closedByUser = false
    clearReconnectTimer()

    if (ws) {
      try { ws.close() } catch (e) {}
      ws = null
    }

    setStatus('connecting')
    logLine(`[client] connect ${url}`)

    ws = new WebSocket(url)

    ws.addEventListener('open', () => {
      attempt = 0
      setStatus('connected')
      logLine('[client] connected')
    })

    ws.addEventListener('close', () => {
      ws = null
      setStatus('disconnected')
      logLine('[client] disconnected')
      scheduleReconnect()
    })

    ws.addEventListener('error', () => {
      // close will follow in most cases
      logLine('[client] ws error')
    })

    ws.addEventListener('message', (ev) => {
      let msg = null
      try {
        msg = JSON.parse(ev.data)
      } catch (e) {
        return
      }

      if (msg.type === 'ws:welcome') {
        logLine(`[server] welcome ${JSON.stringify(msg.payload)}`)
        return
      }

      if (msg.type === 'bus.event') {
        const { bus, event } = msg.payload || {}
        const line = `[${bus}] ${event?.type} ${event?.ts || ''} ${event?.source || ''} ${JSON.stringify(event?.payload || {})}`
        logLine(line)
        return
      }

      logLine(`[server] ${JSON.stringify(msg)}`)
    })
  }

  const disconnect = () => {
    closedByUser = true
    clearReconnectTimer()

    if (!ws) {
      setStatus('disconnected')
      return
    }

    try { ws.close() } catch (e) {}
    ws = null
    setStatus('disconnected')
    logLine('[client] manual disconnect')
  }

  connectBtn.addEventListener('click', () => {
    if (ws) {
      disconnect()
      connectBtn.textContent = 'Connect'
      return
    }

    connect()
    connectBtn.textContent = 'Disconnect'
  })

  clearBtn.addEventListener('click', () => {
    logEl.textContent = ''
  })

  // auto-connect on load
  connect()
  connectBtn.textContent = 'Disconnect'
</script>
</body>
</html>
